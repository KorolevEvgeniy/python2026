Дней на выполнение: 11

result: 85/100

1) **Сильные стороны**
- Реализованы все требуемые классы: `DiscountPolicy`, `PercentDiscount`, `FixedDiscount`, `PriceCalculator`, `MinPriceDiscount`.
- Используется абстрактный класс с абстрактным методом `apply`, что соответствует условию.
- В наследниках корректно применяется `super().__init__` и `super().clamp_price`.
- В `FixedDiscount.apply` используется `max(discounted_price, 0.0)`, что гарантирует неотрицательность цены.
- Добавлен блок проверки с созданием объектов и вызовом методов, включая тестовые цены.
- Код читаем, имена переменных понятны, структура логична.

2) **Ошибки и недочёты**

**Блокирующие (ломает выполнение требований задания)**
- Отсутствует создание экземпляра `PriceCalculator` с передачей списка политик и вызов `calculate` для разных цен, как требуется в пункте 5 условия задачи 1. Вместо этого студент напрямую вызывает `apply` у каждой политики отдельно. Это нарушает требование использования `PriceCalculator` для последовательного применения политик.
  - Место: после создания `percent_discount` и `fixed_discount` нет кода с `PriceCalculator`.
  - Последствие: не проверена работа `PriceCalculator.calculate`, которая является ключевой частью задания.
  - Исправление: добавить после создания политик:
    ```python
    calculator = PriceCalculator([percent_discount, fixed_discount])
    for price in test_prices:
        final_price = calculator.calculate(price)
        print(f"Итоговая цена после всех скидок: {final_price:.2f} руб.")
    ```

**Значимые (может дать неверный результат на части кейсов, сильно ухудшает качество)**
- В `PercentDiscount.apply` и `MinPriceDiscount.apply` не выполняется проверка, что итоговая цена не становится отрицательной. Хотя в условии явно это требуется только для `FixedDiscount`, логически процентная скидка не должна делать цену отрицательной, но `clamp_price` применяется только к входной цене. Если `percent > 100`, цена станет отрицательной.
  - Место: методы `apply` в `PercentDiscount` и `MinPriceDiscount`.
  - Последствие: при `percent > 100` цена станет отрицательной, что нелогично для скидки.
  - Исправление: добавить `max(..., 0.0)` или вызвать `clamp_price` на результат:
    ```python
    # В PercentDiscount.apply
    discounted_price = normalized_price - discount
    return max(discounted_price, 0.0)
    ```
- Класс `MinPriceDiscount` создан, но не добавлен в `PriceCalculator` для проверки, как требуется в задаче 2 (пункт 2: "Добавь MinPriceDiscount в PriceCalculator и проверь работу на ценах ниже и выше порога").
  - Место: после определения `MinPriceDiscount` нет его использования в `PriceCalculator`.
  - Последствие: не выполнено требование задачи 2.
  - Исправление: создать экземпляр `MinPriceDiscount`, добавить его в `PriceCalculator` и протестировать.

**Минорные (стиль, читаемость, мелкие улучшения без влияния на правильность)**
- В методе `clamp_price` возвращается `0.0` (float), что хорошо, но в условии сказано возвращать `0`. Это несущественно, так как тип `float` допустим.
- В блоке проверки используется список `test_prices`, включая отрицательное значение (-150.0), что хорошо для тестирования `clamp_price`. Однако вывод немного загроможден, можно было сделать более структурированным.
- Отсутствует явная проверка, что нельзя создать экземпляр `DiscountPolicy` (хотя это и так не получится из-за `@abstractmethod`), но это не требуется явно в коде.

3) **Оценка и как она посчитана**
- Функциональность и соответствие условию: 40/50 (минус 10 за отсутствие использования `PriceCalculator` как требуется и неполную проверку `MinPriceDiscount`).
- Качество кода (структура, читаемость, устойчивость, отсутствие дублирования): 27/30 (минус 3 за потенциально отрицательные цены в процентных скидках и мелкие недочёты).
- Стиль и тесты: 18/20 (минус 2 за неполную проверку в блоке тестирования, но код стилистически хорош).
Итог: 40 + 27 + 18 = 85/100.

4) **Если задание выполнено не полностью**
- Отсутствует: использование `PriceCalculator` для последовательного применения политик скидок и проверка `MinPriceDiscount` через `PriceCalculator`.
- Сделано частично: политики созданы, но не интегрированы в калькулятор для финального расчёта.

**Вариант полного решения (дополнение к коду студента):**
Добавить после создания политик и перед циклом `for price in test_prices:`:
```python
# Создание политик (уже есть)
percent_discount = PercentDiscount("Скидка 10%", 10)
fixed_discount = FixedDiscount("Скидка 150 руб.", 150)
min_price_discount = MinPriceDiscount("Скидка 20% при заказе от 1000 руб.", 1000, 20)

# Создание калькуляторов для проверки
calculator1 = PriceCalculator([percent_discount, fixed_discount])
calculator2 = PriceCalculator([min_price_discount, fixed_discount])

# Тестовые цены
test_prices = [500.0, 1200.0, -150.0]

print("\n--- Проверка PriceCalculator ---")
for price in test_prices:
    final1 = calculator1.calculate(price)
    final2 = calculator2.calculate(price)
    print(f"Исходная цена: {price} руб.")
    print(f"  После Percent+Fixed: {final1:.2f} руб.")
    print(f"  После MinPrice+Fixed: {final2:.2f} руб.")
```
Также исправить методы `apply` в `PercentDiscount` и `MinPriceDiscount`, добавив `max(..., 0.0)` для гарантии неотрицательности.
