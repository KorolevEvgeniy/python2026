Время затраченное на выполнение: 1:59

result: 40/100

1) **Сильные стороны**
- Созданы таблицы `Customers` и `Orders` с основными полями, соответствующими условию.
- Добавлены демонстрационные данные, совпадающие с примером из задания.
- Использованы корректные типы данных (INTEGER, TEXT, REAL).
- В таблице `Orders` объявлен внешний ключ на `Customers`, что соответствует требованию связи.
- В коде есть попытка выполнить запросы для разных уровней (закомментированные JOIN и LEFT JOIN, а также запрос с EXCEPT).

2) **Ошибки и недочёты**

**Блокирующие (ломает выполнение требований задания)**
- **Неверный CHECK-ограничение в таблице `Orders` для поля `OrderDate`.**  
  Строка: `OrderDate TEXT CHECK (OrderDate LIKE DATE(OrderDate))`.  
  Функция `DATE()` в SQLite возвращает текст в формате 'YYYY-MM-DD', но использование `LIKE` с результатом функции не проверяет формат строки корректно. Более того, `DATE(OrderDate)` требует, чтобы `OrderDate` уже было допустимой датой, что делает проверку бессмысленной. Это может привести к ошибкам при вставке данных или некорректной валидации.  
  Исправление: Убрать CHECK или заменить на простую проверку формата, например: `CHECK (OrderDate GLOB '[0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9]')`. Поскольку условие не требовало валидации даты, лучше вообще удалить CHECK.

- **Некорректный синтаксис в основном запросе (уровень 3).**  
  Строки с `EXCEPT` и `LEFT JOIN` написаны с ошибками. Запрос:
  ```
  SELECT OrderID, Orders.CustomerID, OrderDate, TotalAmount
  FROM Orders;
  EXCEPT
  SELECT OrderID, Orders.CustomerID, OrderDate, TotalAmount
  FROM Orders;
  LEFT JOIN Customers ON Orders.CustomerID = Customers.CustomerID WHERE Customers.CustomerID IS NULL;
  ```
  Здесь `EXCEPT` разделяет два независимых SELECT-запроса, каждый с точкой с запятой, что приводит к синтаксической ошибке. Второй SELECT также некорректен: после `FROM Orders;` идёт `LEFT JOIN ...`, что нарушает структуру SQL. В результате запрос не выполнится.  
  Исправление: Убрать лишние точки с запятой и правильно объединить запросы. Для уровня 3 корректный запрос мог бы быть:
  ```
  SELECT OrderID, CustomerID, OrderDate, TotalAmount
  FROM Orders
  WHERE CustomerID NOT IN (SELECT CustomerID FROM Customers);
  ```
  Или с использованием `LEFT JOIN`:
  ```
  SELECT Orders.OrderID, Orders.CustomerID, Orders.OrderDate, Orders.TotalAmount
  FROM Orders
  LEFT JOIN Customers ON Orders.CustomerID = Customers.CustomerID
  WHERE Customers.CustomerID IS NULL;
  ```

- **Отсутствует выполнение требований по уровням 1 и 2.**  
  В решении основной запрос (последний) — это просто `SELECT * FROM Orders;`, который не соответствует ни одному из трёх уровней задания. Закомментированные запросы (JOIN и LEFT JOIN) не выполняются, поэтому функциональность не реализована.  
  Исправление: Раскомментировать или написать новые запросы, соответствующие каждому уровню, и обеспечить их выполнение.

**Значимые (может дать неверный результат на части кейсов, сильно ухудшает качество)**
- **Вставка строковых значений для числовых полей.**  
  В `INSERT INTO Customers` значения для `CustomerID` переданы как строки ('1', '2'), хотя поле `CustomerID` имеет тип INTEGER. SQLite допускает неявное преобразование, но это плохая практика и может привести к неожиданным ошибкам в других СУБД.  
  Исправление: Использовать числа без кавычек: `(1, 'John', 'Doe', ...)`.

- **Использование двойных кавычек для строковых значений в INSERT INTO Orders.**  
  Значение даты "2025-02-01" заключено в двойные кавычки, что в SQLite интерпретируется как идентификатор, а не строка. Это может вызвать ошибку или некорректную обработку.  
  Исправление: Заменить двойные кавычки на одинарные: `'2025-02-01'`.

**Минорные (стиль, читаемость, мелкие улучшения без влияния на правильность)**
- **Несогласованное форматирование и отступы.**  
  В CREATE TABLE отступы для полей неодинаковы (например, `FirstName` с отступом 4 пробела, `LastName` с табуляцией). Это ухудшает читаемость.  
  Исправление: Привести отступы к единому стилю, например, использовать 4 пробела для всех уровней.

- **Избыточные операции DROP TABLE в начале.**  
  Строки `DROP TABLE Orders; DROP TABLE Customers;` могут вызвать ошибку, если таблицы не существуют (в SQLite это предупреждение, но лучше использовать `DROP TABLE IF EXISTS`).  
  Исправление: Заменить на `DROP TABLE IF EXISTS Orders; DROP TABLE IF EXISTS Customers;`.

- **Закомментированный код оставлен в решении.**  
  Закомментированные запросы (JOIN и LEFT JOIN) не удалены, что загромождает код.  
  Исправление: Удалить комментарии или оставить только рабочие запросы.

3) **Оценка и как она посчитана**
- **Функциональность и соответствие условию: 10/50**  
  Минус 40 баллов: таблицы созданы, данные добавлены, но основные запросы не выполнены (уровни 1, 2, 3 не реализованы). Единственный рабочий запрос — `SELECT * FROM Orders;` — не соответствует условию. Также есть ошибки в структуре (CHECK) и синтаксисе запроса уровня 3.

- **Качество кода (структура, читаемость, устойчивость, отсутствие дублирования): 20/30**  
  Минус 10 баллов: код содержит синтаксические ошибки в запросах, некорректные CHECK-ограничения, неверные кавычки для строк, строковые значения для числовых полей, несогласованное форматирование. Это снижает надёжность и читаемость.

- **Стиль и тесты: 10/20**  
  Минус 10 баллов: оставлен закомментированный код, нет пояснений или структурирования по уровням задания. Тесты не требуются по условию, но стиль можно улучшить.

**Итог: 10 + 20 + 10 = 40/100**

4) **Если задание выполнено не полностью**
- **Отсутствует:**  
  - Запрос уровня 1 (перечень клиентов с их заказами через JOIN).  
  - Запрос уровня 2 (клиенты даже без заказов через LEFT JOIN и объединённый список через UNION).  
  - Корректный запрос уровня 3 (заказы без клиентов).  
- **Сделано частично:**  
  - Создание таблиц и вставка данных выполнены, но с мелкими ошибками (CHECK, кавычки).  
  - Попытка написать запросы есть, но они либо закомментированы, либо содержат синтаксические ошибки.

**Вариант полного решения (краткий код):**
```sql
-- Уровень 1: перечень клиентов с заказами
SELECT
    Customers.FirstName,
    Customers.LastName,
    Orders.OrderID,
    Orders.TotalAmount
FROM Customers
JOIN Orders ON Customers.CustomerID = Orders.CustomerID;

-- Уровень 2: клиенты даже без заказов
SELECT
    Customers.FirstName,
    Customers.LastName,
    Orders.OrderID,
    Orders.TotalAmount
FROM Customers
LEFT JOIN Orders ON Customers.CustomerID = Orders.CustomerID;

-- Уровень 2: единый перечень клиентов и заказов (UNION)
SELECT
    Customers.FirstName,
    Customers.LastName,
    NULL AS OrderID,
    NULL AS TotalAmount
FROM Customers
UNION
SELECT
    NULL AS FirstName,
    NULL AS LastName,
    Orders.OrderID,
    Orders.TotalAmount
FROM Orders;

-- Уровень 3: заказы без клиентов
SELECT
    Orders.OrderID,
    Orders.CustomerID,
    Orders.OrderDate,
    Orders.TotalAmount
FROM Orders
LEFT JOIN Customers ON Orders.CustomerID = Customers.CustomerID
WHERE Customers.CustomerID IS NULL;
```
