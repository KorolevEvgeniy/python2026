# Домашняя работа: Функции. Параметры, значения по умолчанию, args, kwargs, область видимости

## Задачи
1.  **Функция для анализа списка покупок**
    -   **Описание задачи:** Тренировка объявления функций, передачи аргументов и использования `return`. Задача учит отличать печать от возврата значения, что является фундаментальным навыком. Требуется создать функцию, которая анализирует список словарей (покупок) и возвращает статистику, а не печатает ее.
    -   **Пример (вход → выход):**
        -   Вход: `items = [{"name": "молоко", "price": 90}, {"name": "хлеб", "price": 50}, {"name": "яблоки", "price": 120}]`
        -   Вызов: `stats = analyze_purchases(items)`
        -   Ожидаемый вывод в `stats`: `{'total': 260, 'count': 3, 'avg_price': 86.67, 'most_expensive': 'яблоки'}`
        -   Граничный случай: пустой список `[]` должен возвращать `{'total': 0, 'count': 0, 'avg_price': 0, 'most_expensive': None}`.
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `analyze_purchases` и принимать один обязательный параметр `items`.
        -   Функция должна возвращать словарь с ключами `total`, `count`, `avg_price`, `most_expensive`.
        -   Нельзя использовать `print` внутри функции для вывода результата. Результат должен быть возвращен.
        -   Обработать случай деления на ноль при пустом списке.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `analyze_purchases` с параметром `items`.
        2.  Инициализируй переменные для суммы, количества, средней цены и названия самого дорогого товара.
        3.  Если список `items` пуст, верни словарь с нулевыми/пустыми значениями.
        4.  Пройдись циклом по каждому элементу в `items`.
        5.  Увеличивай сумму на цену товара.
        6.  Сравнивай цену текущего товара с ценой самого дорогого, обновляй название, если текущий дороже.
        7.  После цикла вычисли среднюю цену (сумма / количество).
        8.  Собери и верни итоговый словарь.
    -   **Рекомендации:**
        -   Функция выполняет одну четкую задачу — анализ. Выносить внутреннюю логику в другие функции не требуется.
        -   Следуй PEP8: имя функции в `snake_case`, используй пробелы вокруг операторов (`=`, `+`, `/`), длина строки кода не должна превышать 79 символов.

2.  **Конфигурируемый генератор цен с безопасными значениями по умолчанию**
    -   **Описание задачи:** Закрепление работы с параметрами, значениями по умолчанию и предотвращение ошибки с изменяемыми объектами. Требуется создать функцию, которая генерирует список цен с учетом базовой стоимости, наценки и скидки, безопасно работая с изменяемым значением по умолчанию.
    -   **Пример (вход → выход):**
        -   Вызов 1: `generate_prices(base=100, count=3)` → `[100, 100, 100]`
        -   Вызов 2: `generate_prices(base=100, count=2, markup=0.1)` → `[110.0, 110.0]` (цена +10%)
        -   Вызов 3: `generate_prices(base=200, count=2, markup=0.2, discount=0.05)` → `[228.0, 228.0]` (цена +20%, затем -5%)
        -   Граничный случай: `generate_prices(base=50, count=0)` → `[]`
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `generate_prices`.
        -   Обязательные параметры: `base` (число), `count` (целое число).
        -   Параметры со значениями по умолчанию: `markup=0.0`, `discount=0.0`.
        -   Параметр `count` определяет длину возвращаемого списка.
        -   **Критически важно:** Значение по умолчанию для изменяемого объекта (например, пустой список `[]`) должно быть задано безопасно, используя `None`-паттерн.
        -   Функция должна возвращать новый список при каждом вызове.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `generate_prices` с параметрами `base`, `count`, `markup=0.0`, `discount=0.0`.
        2.  Внутри функции создай пустой список `result` (не используй значение по умолчанию в параметре!).
        3.  Рассчитай итоговую цену для одного элемента: `price = base * (1 + markup) * (1 - discount)`.
        4.  Используй цикл, повторяющийся `count` раз, чтобы добавить рассчитанную цену в список `result`.
        5.  Верни список `result`.
    -   **Рекомендации:**
        -   Расчет итоговой цены можно вынести в небольшую внутреннюю функцию или оставить как формулу. Для данной задачи вынос не обязателен.
        -   PEP8: используй пробелы после запятых в списке параметров. Именованные аргументы при вызове улучшают читаемость (например, `markup=0.1`).

3.  **Универсальный агрегатор данных с использованием `*args` и `**kwargs`**
    -   **Описание задачи:** Развитие навыка создания гибких функций, принимающих переменное число аргументов. Функция должна агрегировать числовые данные, переданные как позиционные аргументы, и собирать мета-информацию, переданную как именованные аргументы.
    -   **Пример (вход → выход):**
        -   Вызов 1: `aggregate_data(10, 20, 30, operation='sum')` → `{'result': 60, 'count': 3, 'operation': 'sum'}`
        -   Вызов 2: `aggregate_data(5, 7, 9, 1, operation='max', source='sensor_A')` → `{'result': 9, 'count': 4, 'operation': 'max', 'source': 'sensor_A'}`
        -   Вызов 3: `aggregate_data(operation='min')` → `{'result': None, 'count': 0, 'operation': 'min'}` (нет чисел для обработки)
    -   **Критерии проверки и ограничения:**
        -   Функция должна называться `aggregate_data`.
        -   Использовать `*args` для сбора всех позиционных аргументов (числа).
        -   Использовать `**kwargs` для сбора всех именованных аргументов (метаданные).
        -   Обязательно наличие именованного аргумента `operation` (строка: 'sum', 'max', 'min'). Его значение должно быть извлечено из `kwargs`.
        -   Функция возвращает словарь с ключами `result` (результат операции), `count` (количество чисел) и всеми переданными в `kwargs` данными.
        -   Если `args` пуст, `result` должен быть `None`.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `aggregate_data` с параметрами `*args` и `**kwargs`.
        2.  Извлеки значение `operation` из словаря `kwargs` (используй `.get()` со значением по умолчанию, например, 'sum').
        3.  Инициализируй переменную `result` как `None`.
        4.  Если `args` не пуст:
            -   Если `operation` равно 'sum', вычисли сумму чисел в `args`.
            -   Если `operation` равно 'max', найди максимум в `args`.
            -   Если `operation` равно 'min', найди минимум в `args`.
            -   Присвой вычисленное значение переменной `result`.
        5.  Создай словарь для ответа. Добавь в него `result`, `count` (длина `args`) и все пары ключ-значение из `kwargs`.
        6.  Верни этот словарь.
    -   **Рекомендации:**
        -   Логику выбора и выполнения операции (`sum`, `max`, `min`) можно вынести в отдельную вспомогательную функцию или использовать условные операторы внутри. Для ясности оставь внутри.
        -   PEP8: при использовании `*args` и `**kwargs` оставляй пробелы вокруг звездочек в объявлении: `def func(*args, **kwargs):`.

4.  **Менеджер счетчиков с контролем области видимости**
    -   **Описание задачи:** Интеграция всех изученных концепций, включая область видимости, значения по умолчанию и возврат значений. Требуется создать функцию, которая возвращает другую функцию-счетчик, избегая использования `global` и демонстрируя понимание замыкания.
    -   **Описание задачи:** Создай функцию `create_counter`, которая возвращает новую функцию. Возвращаемая функция при каждом вызове увеличивает свой внутренний счетчик и возвращает его текущее значение. Начальное значение счетчика и шаг увеличения должны быть параметризуемы.
    -   **Пример (вход → выход):**
        -   `counter1 = create_counter(start=0, step=1)`
        -   `print(counter1())` → `1`
        -   `print(counter1())` → `2`
        -   `counter2 = create_counter(start=10, step=5)`
        -   `print(counter2())` → `15`
        -   `print(counter2())` → `20`
        -   `print(counter1())` → `3` (счетчики независимы)
    -   **Критерии проверки и ограничения:**
        -   Функция `create_counter` должна принимать два именованных параметра со значениями по умолчанию: `start=0`, `step=1`.
        -   `create_counter` должна возвращать новую функцию (например, `increment`).
        -   Возвращаемая функция не должна принимать аргументов и при каждом вызове возвращать новое значение счетчика.
        -   **Запрещено** использовать `global` для хранения состояния счетчика. Состояние должно сохраняться в замыкании.
        -   Каждый вызов `create_counter` создает независимый счетчик.
    -   **Решение (псевдокод):**
        1.  Объяви функцию `create_counter` с параметрами `start=0` и `step=1`.
        2.  Внутри `create_counter` создай переменную `current_value` и инициализируй ее значением `start`.
        3.  Объяви внутреннюю функцию (например, `increment`), которая не принимает параметров.
        4.  Внутри `increment` используй нелокальную переменную `current_value` (или другой механизм языка для изменения переменной из внешней области видимости).
        5.  В `increment` увеличь `current_value` на `step`.
        6.  Верни из `increment` новое значение `current_value`.
        7.  Верни саму функцию `increment` из `create_counter`.
    -   **Рекомендации:**
        -   Внутренняя функция `increment` и переменная `current_value` образуют замыкание. Это ключевая идея задачи.
        -   PEP8: для коротких внутренних функций допустимо оставить логику внутри. Убедись, что отступы для вложенной функции корректны (обычно 4 пробела).
