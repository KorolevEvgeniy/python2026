# Практическое задание 35.3

Это задание посвящено третьему блоку урока по функциям. В предыдущих блоках вы научились создавать функции с позиционными и именованными аргументами, а также работать со значениями по умолчанию. Сейчас мы переходим к созданию гибких функций, способных работать с переменным количеством входных данных. Этот блок научит вас использовать `*args` и `**kwargs` для сбора аргументов и технике распаковки коллекций при вызове функций.

## Задания

### Описание задачи
Вы разрабатываете модуль для обработки данных о студентах. Данные могут поступать в разном формате и объеме. Ваша задача — создать универсальную функцию `merge_student_data`, которая сможет корректно объединять информацию из нескольких источников.

Функция должна:
1.  Принимать обязательный позиционный аргумент `student_id` (идентификатор студента).
2.  Принимать произвольное количество дополнительных позиционных аргументов через `*args`. Каждый такой аргумент — это кортеж вида `("ключ", значение)`, представляющий отдельный атрибут студента (например, `("имя", "Иван")`).
3.  Принимать произвольное количество именованных аргументов через `**kwargs`. Эти аргументы также представляют собой пары ключ-значение для добавления в данные студента.
4.  Возвращать словарь, где ключом является `student_id`, а значением — другой словарь, объединяющий все переданные атрибуты. Атрибуты из `*args` и `**kwargs` должны быть объединены в один словарь. Если один и тот же ключ передается и через кортеж в `args`, и через `kwargs`, приоритет имеет значение из `kwargs`.

Также создайте вспомогательную функцию `call_merger`, которая демонстрирует технику распаковки. Эта функция должна:
1.  Принимать список `args_list` (список кортежей для `*args`) и словарь `kwargs_dict` (словарь для `**kwargs`).
2.  Вызывать функцию `merge_student_data` с фиксированным `student_id=101`, распаковав переданные ей коллекции.
3.  Возвращать результат этого вызова.

### Пример входных и выходных данных

**Пример 1: Базовый вызов**
```python
# Вызов функции
result = merge_student_data(101, ("name", "Evgeniy"), ("course", "Python"), city="Kazan", course="Advanced Python")
print(result)

# Ожидаемый вывод:
# {
#   101: {
#     'name': 'Evgeniy',
#     'course': 'Advanced Python', # Значение из kwargs перезаписало значение из args
#     'city': 'Kazan'
#   }
# }
```
*Пояснение:* Ключ `"course"` присутствует и в кортеже `("course", "Python")` (переданном через `*args`), и в именованном аргументе `course="Advanced Python"`. Согласно условию, приоритет имеет значение из `kwargs`, поэтому в итоговом словаре сохраняется `"Advanced Python"`.

**Пример 2: Использование распаковки**
```python
# Подготовка данных
additional_info = [("age", 25), ("hobby", "cycling")]
extra_details = {"score": 95, "age": 26} # age снова будет перезаписан

# Вызов вспомогательной функции
result = call_merger(additional_info, extra_details)
print(result)

# Ожидаемый вывод:
# {
#   101: {
#     'age': 26,        # Значение из kwargs_dict перезаписало значение из args_list
#     'hobby': 'cycling',
#     'score': 95
#   }
# }
```
*Пояснение:* Функция `call_merger` получает список кортежей и словарь. Она вызывает `merge_student_data(101, *additional_info, **extra_details)`, распаковывая коллекции в отдельные аргументы.

### Критерии проверки и ограничения
1.  Функция `merge_student_data` должна быть объявлена с параметрами `student_id`, `*args`, `**kwargs`.
2.  Внутри функции необходимо создать пустой словарь для атрибутов студента.
3.  Сначала в этот словарь добавляются все пары из `args` (каждый элемент `args` — это кортеж).
4.  Затем словарь обновляется данными из `kwargs`. Это обеспечит приоритет `kwargs` при совпадении ключей.
5.  Итоговый словарь должен быть возвращен в формате `{student_id: attributes_dict}`.
6.  Функция `call_merger` должна корректно использовать операторы `*` и `**` для распаковки переданных коллекций при вызове `merge_student_data`.
7.  Не используйте темы из будущих блоков: область видимости, глобальные переменные, замыкания.

### Решение задачи (псевдокод)

**Для функции merge_student_data:**
1.  Принять аргументы: идентификатор студента, произвольный список кортежей `*args`, произвольный словарь `**kwargs`.
2.  Создать пустой словарь `attributes`.
3.  Для каждого кортежа `(key, value)` в `args`:
    *   Добавить в словарь `attributes` пару `key: value`.
4.  Обновить словарь `attributes` содержимым словаря `kwargs`. При этом существующие ключи получат новые значения из `kwargs`.
5.  Вернуть словарь, где ключом является `student_id`, а значением — словарь `attributes`.

**Для функции call_merger:**
1.  Принять аргументы: список `args_list` и словарь `kwargs_dict`.
2.  Вызвать функцию `merge_student_data`, передав:
    *   Число `101` в качестве `student_id`.
    *   Распакованный список `args_list` с помощью оператора `*`.
    *   Распакованный словарь `kwargs_dict` с помощью оператора `**`.
3.  Вернуть результат этого вызова.

### Рекомендации
-   Вынести в отдельную функцию: Основную логику по объединению атрибутов из `args` и `kwargs` в один словарь можно было бы выделить в отдельную вспомогательную функцию, например, `_build_attributes_dict(*args, **kwargs)`, чтобы `merge_student_data` была более читаемой. Однако для данной задачи это не является строго обязательным.
-   PEP8:
    *   Используйте осмысленные имена для параметров, например, `student_id`, `args_list`, `kwargs_dict`.
    *   Если строки кода становятся длинными из-за многих аргументов, особенно при распаковке, можно перенести вызов функции на новую строку для лучшей читаемости.
